<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ÁÇπ‰∫ëÂΩ¢ÊÄÅ‰∏éGPUÊ∏≤ÊüìÊé¢Á¥¢</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0d12;
      color: #e6e6e6;
      font-family: "Segoe UI", system-ui, sans-serif;
    }

    #app {
      width: 100%;
      height: 100%;
      position: relative;
    }

    #canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    #hud {
      position: absolute;
      left: 12px;
      top: 12px;
      z-index: 10;
      background: rgba(10, 13, 18, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 14px 16px;
      width: 300px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(10px);
    }

    #hud .title {
      font-size: 16px;
      font-weight: 600;
      margin-bottom: 12px;
      color: #a78bfa;
    }

    #hud .section {
      margin-bottom: 12px;
    }

    #hud .section-title {
      font-size: 11px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 6px;
    }

    #hud .row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    #hud .row.wrap {
      flex-wrap: wrap;
    }

    #hud label {
      font-size: 11px;
      color: #9ca3af;
      min-width: 70px;
    }

    #hud select,
    #hud input[type="range"] {
      flex: 1;
      padding: 6px 8px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      background: #111827;
      color: #e5e7eb;
      font-size: 12px;
    }

    #hud input[type="range"] {
      padding: 0;
      height: 6px;
      cursor: ew-resize;
    }

    #hud .value {
      min-width: 45px;
      text-align: right;
      font-size: 11px;
      color: #9ca3af;
      font-variant-numeric: tabular-nums;
    }

    #hud button {
      padding: 6px 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      background: #1f2937;
      color: #e5e7eb;
      font-size: 11px;
      cursor: pointer;
      transition: all 0.15s;
    }

    #hud button:hover {
      border-color: #a78bfa;
      background: #2d3748;
    }

    #hud button.active {
      background: #4c1d95;
      border-color: #a78bfa;
    }

    #hud button.shape-btn {
      flex: 1;
      min-width: 70px;
    }

    #info {
      font-size: 11px;
      color: #9ca3af;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px;
      border-radius: 8px;
      line-height: 1.8;
    }

    #info .row {
      display: flex;
      justify-content: space-between;
    }

    #info .highlight {
      color: #fbbf24;
      font-weight: 500;
    }

    #info .good {
      color: #34d399;
    }

    #info .warn {
      color: #fbbf24;
    }

    #hint {
      position: absolute;
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(10, 13, 18, 0.8);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 11px;
      color: #6b7280;
    }
  </style>
</head>

<body>
  <div id="app">
    <canvas id="canvas"></canvas>

    <div id="hud">
      <div class="title">üé® ÁÇπ‰∫ëÂΩ¢ÊÄÅÊé¢Á¥¢</div>

      <div class="section">
        <div class="section-title">ÂΩ¢ÊÄÅÈÄâÊã©</div>
        <div class="row wrap" id="shapeButtons"></div>
      </div>

      <div class="section">
        <div class="section-title">ÂèÇÊï∞ÊéßÂà∂</div>
        <div class="row">
          <label>ÁÇπÊï∞Èáè</label>
          <input type="range" id="countSlider" min="100000" max="1000000" step="100000" value="500000" />
          <span class="value" id="countValue">50‰∏á</span>
        </div>
        <div class="row">
          <label>ÁÇπÂ§ßÂ∞è</label>
          <input type="range" id="sizeSlider" min="0.5" max="5" step="0.1" value="1.5" />
          <span class="value" id="sizeValue">1.5</span>
        </div>
        <div class="row">
          <label>Âä®ÁîªÈÄüÂ∫¶</label>
          <input type="range" id="speedSlider" min="0" max="2" step="0.1" value="0.5" />
          <span class="value" id="speedValue">0.5</span>
        </div>
        <div class="row">
          <label>È¢úËâ≤ÊñπÊ°à</label>
          <select id="colorScheme">
            <option value="position">‰ΩçÁΩÆÊò†Â∞Ñ</option>
            <option value="normal">Ê≥ïÁ∫øÊò†Â∞Ñ</option>
            <option value="height">È´òÂ∫¶Êò†Â∞Ñ</option>
            <option value="radial">ÂæÑÂêëÊ∏êÂèò</option>
            <option value="rainbow">ÂΩ©Ëôπ</option>
          </select>
        </div>
      </div>

      <div class="section">
        <div class="section-title">üî¨ ÁΩëÊ†ºÈáçÂª∫ (WebGPU Marching Cubes)</div>
        <div class="row">
          <button id="meshToggle" class="physics-btn">ÁΩëÊ†ºÔºöÂÖ≥</button>
          <button id="rebuildMesh" class="physics-btn">ÈáçÂª∫</button>
        </div>
        <div class="row">
          <label>‰ΩìÁ¥†ÂàÜËæ®Áéá</label>
          <input type="range" id="gridResSlider" min="32" max="256" step="8" value="64" />
          <span class="value" id="gridResValue">64¬≥</span>
        </div>
        <div class="row">
          <label>Á≠âÂÄºÈù¢ÈòàÂÄº</label>
          <input type="range" id="isoValueSlider" min="0.1" max="2.0" step="0.1" value="0.5" />
          <span class="value" id="isoValueValue">0.5</span>
        </div>
        <div class="row">
          <label>Êï£Â∞ÑÂçäÂæÑ</label>
          <input type="range" id="splatRadiusSlider" min="0.5" max="3.0" step="0.1" value="1.5" />
          <span class="value" id="splatRadiusValue">1.5</span>
        </div>
        <div class="row">
          <label>ÁΩëÊ†ºÈÄèÊòéÂ∫¶</label>
          <input type="range" id="meshOpacitySlider" min="0.1" max="1.0" step="0.05" value="0.8" />
          <span class="value" id="meshOpacityValue">0.80</span>
        </div>
      </div>

      <div id="info">
        <div class="row"><span>ÂΩìÂâçÂΩ¢ÊÄÅ</span><span class="highlight" id="infoShape">-</span></div>
        <div class="row"><span>ÁÇπÊï∞Èáè</span><span id="infoCount">0</span></div>
        <div class="row"><span>ÁîüÊàêËÄóÊó∂</span><span id="infoGenTime">0</span> ms</div>
        <div class="row"><span>Ê∏≤ÊüìÊ®°Âºè</span><span id="infoRenderMode">-</span></div>
        <div class="row"><span>ÁΩëÊ†ºÈáçÂª∫</span><span id="infoMesh" class="good">-</span></div>
        <div class="row"><span>ÁΩëÊ†º‰∏âËßíÂΩ¢</span><span id="infoTriangles">-</span></div>
        <div class="row"><span>FPS</span><span class="highlight" id="infoFps">0</span></div>
        <div class="row"><span>Draw Calls</span><span id="infoDrawCalls">0</span></div>
        <div class="row"><span>Compute ËÄóÊó∂</span><span id="infoComputeTime">-</span></div>
      </div>
    </div>

    <div id="hint">Â∑¶ÈîÆÊóãËΩ¨ | Âè≥ÈîÆÂπ≥Áßª | ÊªöËΩÆÁº©Êîæ | ÁÇπÂáª"ÁΩëÊ†º"ÊåâÈíÆÂêØÁî® Marching Cubes ÁΩëÊ†ºÈáçÂª∫</div>

    <div id="webgpu-status"
      style="position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.9);color:#ef4444;padding:20px 30px;border-radius:10px;z-index:1000;display:none;">
      <p>ÁΩëÊ†ºÈáçÂª∫ÂäüËÉΩÈúÄË¶Å WebGPU ÊîØÊåÅ„ÄÇ<br>
        ËØ∑‰ΩøÁî® Chrome 113+ Êàñ Edge 113+ ÊµèËßàÂô®„ÄÇ</p>
    </div>
  </div>

  <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.171.0/build/three.webgpu.js",
        "three/tsl": "https://unpkg.com/three@0.171.0/build/three.webgpu.js",
        "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
      }
    }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";

    // TSL ÂáΩÊï∞‰ªé THREE.TSL ÂëΩÂêçÁ©∫Èó¥‰∏≠Ëß£ÊûÑ
    const {
      attribute, uniform, varying, varyingProperty,
      vec2, vec3, vec4, float, int, mat2,
      add, sub, mul, div, mod, abs, sign, floor, ceil, fract, sqrt, pow, exp, log,
      sin, cos, tan, asin, acos, atan, atan2,
      min, max, clamp, mix, step, smoothstep,
      length, distance, dot, cross, normalize, reflect,
      positionLocal, positionWorld, modelViewMatrix, projectionMatrix,
      cameraPosition, modelWorldMatrix,
      Fn, If, Loop,
      hash,
    } = THREE.TSL;

    // ==================== ÁÇπ‰∫ëËΩ¨ÁΩëÊ†º Compute Shaders (WGSL) ====================

    // Ê∏ÖÈô§‰ΩìÁ¥†ÂØÜÂ∫¶Âú∫ÂíåÈ¢úËâ≤Âú∫
    const clearVoxelShader = /* wgsl */`
      @group(0) @binding(0) var<storage, read_write> voxels: array<atomic<i32>>;
      @group(0) @binding(1) var<storage, read_write> voxelColorsR: array<atomic<i32>>;
      @group(0) @binding(2) var<storage, read_write> voxelColorsG: array<atomic<i32>>;
      @group(0) @binding(3) var<storage, read_write> voxelColorsB: array<atomic<i32>>;
      @group(0) @binding(4) var<uniform> gridSize: vec3u;
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) id: vec3u) {
        let gridCount = gridSize.x * gridSize.y * gridSize.z;
        if (id.x < gridCount) {
          atomicStore(&voxels[id.x], 0);
          atomicStore(&voxelColorsR[id.x], 0);
          atomicStore(&voxelColorsG[id.x], 0);
          atomicStore(&voxelColorsB[id.x], 0);
        }
      }
    `;

    // ÁÇπ‰∫ëÊï£Â∞ÑÂà∞‰ΩìÁ¥†ÁΩëÊ†º (P2G - Point to Grid)
    const splatPointsShader = /* wgsl */`
      @group(0) @binding(0) var<storage, read> points: array<vec4f>;
      @group(0) @binding(1) var<storage, read> colors: array<vec4f>;
      @group(0) @binding(2) var<storage, read_write> voxels: array<atomic<i32>>;
      @group(0) @binding(3) var<storage, read_write> voxelColorsR: array<atomic<i32>>;
      @group(0) @binding(4) var<storage, read_write> voxelColorsG: array<atomic<i32>>;
      @group(0) @binding(5) var<storage, read_write> voxelColorsB: array<atomic<i32>>;
      @group(0) @binding(6) var<uniform> gridSize: vec3u;
      @group(0) @binding(7) var<uniform> numPoints: u32;
      @group(0) @binding(8) var<uniform> params: SplatParams;
      
      struct SplatParams {
        gridMin: vec3f,
        _pad0: f32,
        gridMax: vec3f,
        _pad1: f32,
        splatRadius: f32,
        _pad2: f32,
        _pad3: f32,
        _pad4: f32,
      }
      
      const FP_SCALE: f32 = 10000.0;
      const COLOR_SCALE: f32 = 1000.0;
      
      fn gaussianWeight(dist: f32, radius: f32) -> f32 {
        let sigma = radius * 0.5;
        return exp(-dist * dist / (2.0 * sigma * sigma));
      }
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) id: vec3u) {
        if (id.x >= numPoints) { return; }
        
        let pos = points[id.x].xyz;
        let color = colors[id.x].xyz;
        
        let gridRange = params.gridMax - params.gridMin;
        let normalizedPos = (pos - params.gridMin) / gridRange;
        let gridPos = normalizedPos * vec3f(f32(gridSize.x), f32(gridSize.y), f32(gridSize.z));
        
        let cellRadius = i32(ceil(params.splatRadius));
        let centerCell = vec3i(floor(gridPos));
        
        for (var dx = -cellRadius; dx <= cellRadius; dx++) {
          for (var dy = -cellRadius; dy <= cellRadius; dy++) {
            for (var dz = -cellRadius; dz <= cellRadius; dz++) {
              let cellCoord = centerCell + vec3i(dx, dy, dz);
              
              if (cellCoord.x < 0 || cellCoord.x >= i32(gridSize.x) ||
                  cellCoord.y < 0 || cellCoord.y >= i32(gridSize.y) ||
                  cellCoord.z < 0 || cellCoord.z >= i32(gridSize.z)) {
                continue;
              }
              
              let cellCenter = vec3f(f32(cellCoord.x) + 0.5, f32(cellCoord.y) + 0.5, f32(cellCoord.z) + 0.5);
              let dist = length(gridPos - cellCenter);
              
              if (dist > params.splatRadius) { continue; }
              
              let weight = gaussianWeight(dist, params.splatRadius);
              let densityContrib = i32(weight * FP_SCALE);
              
              let voxelIndex = u32(cellCoord.x) * gridSize.y * gridSize.z +
                               u32(cellCoord.y) * gridSize.z +
                               u32(cellCoord.z);
              
              atomicAdd(&voxels[voxelIndex], densityContrib);
              let colorWeight = weight * COLOR_SCALE;
              atomicAdd(&voxelColorsR[voxelIndex], i32(color.r * colorWeight));
              atomicAdd(&voxelColorsG[voxelIndex], i32(color.g * colorWeight));
              atomicAdd(&voxelColorsB[voxelIndex], i32(color.b * colorWeight));
            }
          }
        }
      }
    `;

    // ÂΩí‰∏ÄÂåñÂØÜÂ∫¶Âú∫
    const normalizeDensityShader = /* wgsl */`
      @group(0) @binding(0) var<storage, read> voxelsIn: array<i32>;
      @group(0) @binding(1) var<storage, read_write> densityOut: array<f32>;
      @group(0) @binding(2) var<uniform> gridSize: vec3u;
      @group(0) @binding(3) var<storage, read> voxelColorsR: array<i32>;
      @group(0) @binding(4) var<storage, read> voxelColorsG: array<i32>;
      @group(0) @binding(5) var<storage, read> voxelColorsB: array<i32>;
      @group(0) @binding(6) var<storage, read_write> colorsOut: array<vec4f>;
      
      const FP_SCALE: f32 = 10000.0;
      const COLOR_SCALE: f32 = 1000.0;
      
      @compute @workgroup_size(64)
      fn main(@builtin(global_invocation_id) id: vec3u) {
        let gridCount = gridSize.x * gridSize.y * gridSize.z;
        if (id.x >= gridCount) { return; }
        
        let density = f32(voxelsIn[id.x]);
        densityOut[id.x] = density / FP_SCALE;
        
        if (density > 0.0) {
          let totalWeight = density / FP_SCALE * COLOR_SCALE;
          colorsOut[id.x] = vec4f(
            f32(voxelColorsR[id.x]) / totalWeight,
            f32(voxelColorsG[id.x]) / totalWeight,
            f32(voxelColorsB[id.x]) / totalWeight,
            1.0
          );
        } else {
          colorsOut[id.x] = vec4f(0.5, 0.5, 0.5, 1.0);
        }
      }
    `;

    // Marching Cubes ‰∏ªËÆ°ÁÆóÁùÄËâ≤Âô®
    const marchingCubesShader = /* wgsl */`
      struct TriangleVertex {
        position: vec3f,
        _pad0: f32,
        normal: vec3f,
        _pad1: f32,
        color: vec3f,
        _pad2: f32,
      }
      
      struct MCParams {
        isoValue: f32,
        gridSizeX: u32,
        gridSizeY: u32,
        gridSizeZ: u32,
      }
      
      @group(0) @binding(0) var<storage, read> density: array<f32>;
      @group(0) @binding(1) var<storage, read_write> vertices: array<TriangleVertex>;
      @group(0) @binding(2) var<storage, read_write> triangleCount: atomic<u32>;
      @group(0) @binding(3) var<uniform> params: MCParams;
      @group(0) @binding(4) var<storage, read> edgeTable: array<u32>;
      @group(0) @binding(5) var<storage, read> triTable: array<i32>;
      @group(0) @binding(6) var<uniform> gridMin: vec3f;
      @group(0) @binding(7) var<uniform> gridMax: vec3f;
      @group(0) @binding(8) var<storage, read> voxelColors: array<vec4f>;
      
      fn getVoxelIndex(x: u32, y: u32, z: u32) -> u32 {
        return x * params.gridSizeY * params.gridSizeZ + y * params.gridSizeZ + z;
      }
      
      fn getDensity(x: i32, y: i32, z: i32) -> f32 {
        if (x < 0 || x >= i32(params.gridSizeX) ||
            y < 0 || y >= i32(params.gridSizeY) ||
            z < 0 || z >= i32(params.gridSizeZ)) {
          return 0.0;
        }
        return density[getVoxelIndex(u32(x), u32(y), u32(z))];
      }
      
      fn getColor(x: i32, y: i32, z: i32) -> vec3f {
        if (x < 0 || x >= i32(params.gridSizeX) ||
            y < 0 || y >= i32(params.gridSizeY) ||
            z < 0 || z >= i32(params.gridSizeZ)) {
          return vec3f(0.5, 0.5, 0.5);
        }
        return voxelColors[getVoxelIndex(u32(x), u32(y), u32(z))].xyz;
      }
      
      fn interpolateVertex(p1: vec3f, p2: vec3f, v1: f32, v2: f32, iso: f32) -> vec3f {
        if (abs(iso - v1) < 0.00001) { return p1; }
        if (abs(iso - v2) < 0.00001) { return p2; }
        if (abs(v1 - v2) < 0.00001) { return p1; }
        let t = (iso - v1) / (v2 - v1);
        return p1 + t * (p2 - p1);
      }
      
      fn interpolateColor(c1: vec3f, c2: vec3f, v1: f32, v2: f32, iso: f32) -> vec3f {
        if (abs(iso - v1) < 0.00001) { return c1; }
        if (abs(iso - v2) < 0.00001) { return c2; }
        if (abs(v1 - v2) < 0.00001) { return c1; }
        let t = (iso - v1) / (v2 - v1);
        return mix(c1, c2, t);
      }
      
      @compute @workgroup_size(4, 4, 4)
      fn main(@builtin(global_invocation_id) id: vec3u) {
        let x = id.x;
        let y = id.y;
        let z = id.z;
        
        if (x >= params.gridSizeX - 1 || y >= params.gridSizeY - 1 || z >= params.gridSizeZ - 1) {
          return;
        }
        
        let ix = i32(x);
        let iy = i32(y);
        let iz = i32(z);
        
        var cubeValues: array<f32, 8>;
        cubeValues[0] = getDensity(ix,     iy,     iz);
        cubeValues[1] = getDensity(ix + 1, iy,     iz);
        cubeValues[2] = getDensity(ix + 1, iy + 1, iz);
        cubeValues[3] = getDensity(ix,     iy + 1, iz);
        cubeValues[4] = getDensity(ix,     iy,     iz + 1);
        cubeValues[5] = getDensity(ix + 1, iy,     iz + 1);
        cubeValues[6] = getDensity(ix + 1, iy + 1, iz + 1);
        cubeValues[7] = getDensity(ix,     iy + 1, iz + 1);
        
        var cubeColors: array<vec3f, 8>;
        cubeColors[0] = getColor(ix,     iy,     iz);
        cubeColors[1] = getColor(ix + 1, iy,     iz);
        cubeColors[2] = getColor(ix + 1, iy + 1, iz);
        cubeColors[3] = getColor(ix,     iy + 1, iz);
        cubeColors[4] = getColor(ix,     iy,     iz + 1);
        cubeColors[5] = getColor(ix + 1, iy,     iz + 1);
        cubeColors[6] = getColor(ix + 1, iy + 1, iz + 1);
        cubeColors[7] = getColor(ix,     iy + 1, iz + 1);
        
        var cubeIndex: u32 = 0u;
        if (cubeValues[0] > params.isoValue) { cubeIndex |= 1u; }
        if (cubeValues[1] > params.isoValue) { cubeIndex |= 2u; }
        if (cubeValues[2] > params.isoValue) { cubeIndex |= 4u; }
        if (cubeValues[3] > params.isoValue) { cubeIndex |= 8u; }
        if (cubeValues[4] > params.isoValue) { cubeIndex |= 16u; }
        if (cubeValues[5] > params.isoValue) { cubeIndex |= 32u; }
        if (cubeValues[6] > params.isoValue) { cubeIndex |= 64u; }
        if (cubeValues[7] > params.isoValue) { cubeIndex |= 128u; }
        
        if (edgeTable[cubeIndex] == 0u) { return; }
        
        let cellSize = (gridMax - gridMin) / vec3f(f32(params.gridSizeX), f32(params.gridSizeY), f32(params.gridSizeZ));
        let basePos = gridMin + vec3f(f32(x), f32(y), f32(z)) * cellSize;
        
        var cubePos: array<vec3f, 8>;
        cubePos[0] = basePos;
        cubePos[1] = basePos + vec3f(cellSize.x, 0.0, 0.0);
        cubePos[2] = basePos + vec3f(cellSize.x, cellSize.y, 0.0);
        cubePos[3] = basePos + vec3f(0.0, cellSize.y, 0.0);
        cubePos[4] = basePos + vec3f(0.0, 0.0, cellSize.z);
        cubePos[5] = basePos + vec3f(cellSize.x, 0.0, cellSize.z);
        cubePos[6] = basePos + cellSize;
        cubePos[7] = basePos + vec3f(0.0, cellSize.y, cellSize.z);
        
        let defaultColor = vec3f(0.5, 0.5, 0.5);
        var vertList: array<vec3f, 12> = array<vec3f, 12>(
          basePos, basePos, basePos, basePos,
          basePos, basePos, basePos, basePos,
          basePos, basePos, basePos, basePos
        );
        var colorList: array<vec3f, 12> = array<vec3f, 12>(
          defaultColor, defaultColor, defaultColor, defaultColor,
          defaultColor, defaultColor, defaultColor, defaultColor,
          defaultColor, defaultColor, defaultColor, defaultColor
        );
        let edges = edgeTable[cubeIndex];
        
        if ((edges & 1u) != 0u)    { vertList[0]  = interpolateVertex(cubePos[0], cubePos[1], cubeValues[0], cubeValues[1], params.isoValue); colorList[0]  = interpolateColor(cubeColors[0], cubeColors[1], cubeValues[0], cubeValues[1], params.isoValue); }
        if ((edges & 2u) != 0u)    { vertList[1]  = interpolateVertex(cubePos[1], cubePos[2], cubeValues[1], cubeValues[2], params.isoValue); colorList[1]  = interpolateColor(cubeColors[1], cubeColors[2], cubeValues[1], cubeValues[2], params.isoValue); }
        if ((edges & 4u) != 0u)    { vertList[2]  = interpolateVertex(cubePos[2], cubePos[3], cubeValues[2], cubeValues[3], params.isoValue); colorList[2]  = interpolateColor(cubeColors[2], cubeColors[3], cubeValues[2], cubeValues[3], params.isoValue); }
        if ((edges & 8u) != 0u)    { vertList[3]  = interpolateVertex(cubePos[3], cubePos[0], cubeValues[3], cubeValues[0], params.isoValue); colorList[3]  = interpolateColor(cubeColors[3], cubeColors[0], cubeValues[3], cubeValues[0], params.isoValue); }
        if ((edges & 16u) != 0u)   { vertList[4]  = interpolateVertex(cubePos[4], cubePos[5], cubeValues[4], cubeValues[5], params.isoValue); colorList[4]  = interpolateColor(cubeColors[4], cubeColors[5], cubeValues[4], cubeValues[5], params.isoValue); }
        if ((edges & 32u) != 0u)   { vertList[5]  = interpolateVertex(cubePos[5], cubePos[6], cubeValues[5], cubeValues[6], params.isoValue); colorList[5]  = interpolateColor(cubeColors[5], cubeColors[6], cubeValues[5], cubeValues[6], params.isoValue); }
        if ((edges & 64u) != 0u)   { vertList[6]  = interpolateVertex(cubePos[6], cubePos[7], cubeValues[6], cubeValues[7], params.isoValue); colorList[6]  = interpolateColor(cubeColors[6], cubeColors[7], cubeValues[6], cubeValues[7], params.isoValue); }
        if ((edges & 128u) != 0u)  { vertList[7]  = interpolateVertex(cubePos[7], cubePos[4], cubeValues[7], cubeValues[4], params.isoValue); colorList[7]  = interpolateColor(cubeColors[7], cubeColors[4], cubeValues[7], cubeValues[4], params.isoValue); }
        if ((edges & 256u) != 0u)  { vertList[8]  = interpolateVertex(cubePos[0], cubePos[4], cubeValues[0], cubeValues[4], params.isoValue); colorList[8]  = interpolateColor(cubeColors[0], cubeColors[4], cubeValues[0], cubeValues[4], params.isoValue); }
        if ((edges & 512u) != 0u)  { vertList[9]  = interpolateVertex(cubePos[1], cubePos[5], cubeValues[1], cubeValues[5], params.isoValue); colorList[9]  = interpolateColor(cubeColors[1], cubeColors[5], cubeValues[1], cubeValues[5], params.isoValue); }
        if ((edges & 1024u) != 0u) { vertList[10] = interpolateVertex(cubePos[2], cubePos[6], cubeValues[2], cubeValues[6], params.isoValue); colorList[10] = interpolateColor(cubeColors[2], cubeColors[6], cubeValues[2], cubeValues[6], params.isoValue); }
        if ((edges & 2048u) != 0u) { vertList[11] = interpolateVertex(cubePos[3], cubePos[7], cubeValues[3], cubeValues[7], params.isoValue); colorList[11] = interpolateColor(cubeColors[3], cubeColors[7], cubeValues[3], cubeValues[7], params.isoValue); }
        
        let triTableOffset = cubeIndex * 16u;
        for (var i = 0u; i < 16u; i += 3u) {
          let e0 = triTable[triTableOffset + i];
          if (e0 < 0) { break; }
          let e1 = triTable[triTableOffset + i + 1u];
          let e2 = triTable[triTableOffset + i + 2u];
          
          if (e0 > 11 || e1 > 11 || e2 > 11 || e1 < 0 || e2 < 0) { continue; }
          
          let v0 = vertList[u32(e0)];
          let v1 = vertList[u32(e1)];
          let v2 = vertList[u32(e2)];
          let c0 = colorList[u32(e0)];
          let c1 = colorList[u32(e1)];
          let c2 = colorList[u32(e2)];
          
          let edge1 = v1 - v0;
          let edge2 = v2 - v0;
          let faceNormal = cross(edge1, edge2);
          
          if (length(faceNormal) < 0.0001) { continue; }
          
          let normal = normalize(faceNormal);
          
          let triIdx = atomicAdd(&triangleCount, 1u);
          let baseIdx = triIdx * 3u;
          
          if (baseIdx + 2u < arrayLength(&vertices)) {
            vertices[baseIdx].position = v0;
            vertices[baseIdx].normal = normal;
            vertices[baseIdx].color = c0;
            vertices[baseIdx + 1u].position = v1;
            vertices[baseIdx + 1u].normal = normal;
            vertices[baseIdx + 1u].color = c1;
            vertices[baseIdx + 2u].position = v2;
            vertices[baseIdx + 2u].normal = normal;
            vertices[baseIdx + 2u].color = c2;
          }
        }
      }
    `;

    // ==================== ÂΩ¢ÊÄÅÂÆö‰πâ ====================
    const SHAPES = {
      sphere: { name: "ÁêÉ‰Ωì", icon: "", description: "ÂùáÂåÄÂàÜÂ∏ÉÂú®ÁêÉÈù¢‰∏ä" },
      cube: { name: "Á´ãÊñπ‰Ωì", icon: "", description: "Á´ãÊñπ‰ΩìË°®Èù¢Êàñ‰ΩìÁßØÂàÜÂ∏É" },
      wave: { name: "Ê≥¢Êµ™", icon: "", description: "Ê≠£Âº¶Ê≥¢Âä®ÁöÑÂπ≥Èù¢" },
      galaxy: { name: "ÊòüÁ≥ª", icon: "", description: "Ëû∫ÊóãËáÇÊòüÁ≥ªÂΩ¢ÊÄÅ" },
    };

    // ==================== TSL Uniform ËäÇÁÇπ ====================
    const uTime = uniform(0);
    const uSize = uniform(1.5);
    const uAnimSpeed = uniform(0.5);
    const uShape = uniform(0);
    const uColorScheme = uniform(0);

    // ==================== TSL Â∑•ÂÖ∑ÂáΩÊï∞ ====================
    const PI = float(Math.PI);
    const TAU = float(Math.PI * 2);

    // HSV to RGB ËΩ¨Êç¢
    const hsv2rgb = Fn(([h, s, v]) => {
      const K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      const p = abs(fract(vec3(h, h, h).add(vec3(K.x, K.y, K.z))).mul(6.0).sub(vec3(K.w, K.w, K.w)));
      return v.mul(mix(vec3(K.x, K.x, K.x), clamp(p.sub(vec3(K.x, K.x, K.x)), 0.0, 1.0), s));
    });

    // ÁêÉÈù¢ÂùêÊ†áËΩ¨Êç¢
    const spherical = Fn(([theta, phi, r]) => {
      const sinPhi = sin(phi);
      return vec3(
        r.mul(sinPhi).mul(cos(theta)),
        r.mul(cos(phi)),
        r.mul(sinPhi).mul(sin(theta))
      );
    });

    // ÁÆÄÂçïÂô™Â£∞ÂáΩÊï∞
    const simpleHash = Fn(([n]) => {
      return fract(sin(n).mul(43758.5453));
    });

    // ==================== TSL ÂΩ¢ÊÄÅÁîüÊàêÂáΩÊï∞ ====================
    // ÁêÉ‰ΩìÂΩ¢ÊÄÅ
    const generateSphere = Fn(([base, time]) => {
      const r1 = base.x;
      const r2 = base.y;
      const r3 = base.z;
      const theta = r1.mul(TAU);
      const phi = acos(r2.mul(2.0).sub(1.0));
      const radius = float(50.0).mul(pow(r3, 0.333));
      const pos = spherical(theta, phi, radius);
      const breath = float(1.0).add(float(0.1).mul(sin(time.mul(2.0).add(radius.mul(0.1)))));
      return pos.mul(breath);
    });

    // Á´ãÊñπ‰ΩìÂΩ¢ÊÄÅ
    const generateCube = Fn(([base, time]) => {
      const pos = base.sub(0.5).mul(100.0);
      const pulse = float(1.0).add(float(0.05).mul(sin(time.mul(3.0).add(length(pos).mul(0.05)))));
      return pos.mul(pulse);
    });


    // Ê≥¢Êµ™ÂΩ¢ÊÄÅ
    const generateWave = Fn(([base, time]) => {
      const r1 = base.x;
      const r2 = base.y;
      const r3 = base.z;
      const x = r1.sub(0.5).mul(100.0);
      const z = r2.sub(0.5).mul(100.0);
      const y = sin(x.mul(0.1).add(time)).mul(10.0)
        .add(cos(z.mul(0.1).add(time.mul(0.7))).mul(10.0))
        .add(r3.sub(0.5).mul(5.0));
      return vec3(x, y, z);
    });

    // ÊòüÁ≥ªÂΩ¢ÊÄÅ
    const generateGalaxy = Fn(([base, time]) => {
      const r1 = base.x;
      const r2 = base.y;
      const r3 = base.z;
      const arm = floor(r1.mul(4.0));
      const t = r2;
      const baseAngle = arm.mul(PI.mul(0.5)).add(t.mul(TAU)).add(t.mul(t).mul(PI));
      const angle = baseAngle.add(time.mul(0.2));
      const radius = t.mul(50.0).add(r3.mul(10.0));
      const height = simpleHash(r1.mul(10.0).add(r2.mul(57.0))).sub(0.5).mul(10.0).mul(float(1.0).sub(t));
      return vec3(
        cos(angle).mul(radius),
        height,
        sin(angle).mul(radius)
      );
    });


    // ==================== TSL È¢úËâ≤ËÆ°ÁÆóÂáΩÊï∞ ====================
    const computeColor = Fn(([pos, scheme]) => {
      const normalizedPos = normalize(pos);
      const len = length(pos);

      // ‰ΩçÁΩÆÊò†Â∞Ñ (scheme 0)
      const colorPosition = normalizedPos.mul(0.5).add(0.5);

      // Ê≥ïÁ∫øÊò†Â∞Ñ (scheme 1) - ‰∏é‰ΩçÁΩÆÊò†Â∞ÑÁõ∏Âêå
      const colorNormal = normalizedPos.mul(0.5).add(0.5);

      // È´òÂ∫¶Êò†Â∞Ñ (scheme 2)
      const h = pos.y.add(50.0).div(100.0);
      const colorHeight = hsv2rgb(float(0.6).sub(h.mul(0.4)), 0.8, 0.9);

      // ÂæÑÂêëÊ∏êÂèò (scheme 3)
      const d = len.div(60.0);
      const colorRadial = hsv2rgb(float(0.8).sub(d.mul(0.3)), 0.7, 0.9);

      // ÂΩ©Ëôπ (scheme 4)
      const angle = atan2(pos.z, pos.x).div(TAU).add(0.5);
      const colorRainbow = hsv2rgb(angle, 0.8, 0.9);

      // Ê†πÊçÆ scheme ÈÄâÊã©È¢úËâ≤
      return mix(
        mix(
          mix(
            mix(colorPosition, colorNormal, step(0.5, scheme)),
            colorHeight, step(1.5, scheme)
          ),
          colorRadial, step(2.5, scheme)
        ),
        colorRainbow, step(3.5, scheme)
      );
    });

    // ==================== ÁΩëÊ†ºÈáçÂª∫Âô®Á±ª (GPU Marching Cubes) ====================
    class MeshReconstructor {
      constructor() {
        this.device = null;
        this.initialized = false;
        this.numPoints = 0;
        this.gridSize = [64, 64, 64];
        this.triangleCount = 0;
        this.params = {
          isoValue: 0.5,
          splatRadius: 1.5,
          gridMin: [-60, -60, -60],
          gridMax: [60, 60, 60],
        };
        this.lastComputeTime = 0;
      }

      async init() {
        if (!navigator.gpu) {
          console.warn("WebGPU not supported for mesh reconstruction");
          return false;
        }
        try {
          const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" });
          if (!adapter) return false;

          const adapterLimits = adapter.limits;
          const maxBufferSize = Math.min(adapterLimits.maxBufferSize, 1024 * 1024 * 1024);
          const maxStorageBufferBindingSize = Math.min(adapterLimits.maxStorageBufferBindingSize, 1024 * 1024 * 1024);

          this.device = await adapter.requestDevice({
            requiredLimits: { maxBufferSize, maxStorageBufferBindingSize }
          });
          this.maxBufferSize = this.device.limits.maxBufferSize;

          this.createLookupTables();
          this.createShaderModules();
          this.createPipelines();

          this.initialized = true;
          console.log("MeshReconstructor WebGPU initialized");
          return true;
        } catch (e) {
          console.error("MeshReconstructor init failed:", e);
          return false;
        }
      }

      createLookupTables() {
        // Edge table
        this.edgeTable = new Uint32Array([
          0x0, 0x109, 0x203, 0x30a, 0x406, 0x50f, 0x605, 0x70c,
          0x80c, 0x905, 0xa0f, 0xb06, 0xc0a, 0xd03, 0xe09, 0xf00,
          0x190, 0x99, 0x393, 0x29a, 0x596, 0x49f, 0x795, 0x69c,
          0x99c, 0x895, 0xb9f, 0xa96, 0xd9a, 0xc93, 0xf99, 0xe90,
          0x230, 0x339, 0x33, 0x13a, 0x636, 0x73f, 0x435, 0x53c,
          0xa3c, 0xb35, 0x83f, 0x936, 0xe3a, 0xf33, 0xc39, 0xd30,
          0x3a0, 0x2a9, 0x1a3, 0xaa, 0x7a6, 0x6af, 0x5a5, 0x4ac,
          0xbac, 0xaa5, 0x9af, 0x8a6, 0xfaa, 0xea3, 0xda9, 0xca0,
          0x460, 0x569, 0x663, 0x76a, 0x66, 0x16f, 0x265, 0x36c,
          0xc6c, 0xd65, 0xe6f, 0xf66, 0x86a, 0x963, 0xa69, 0xb60,
          0x5f0, 0x4f9, 0x7f3, 0x6fa, 0x1f6, 0xff, 0x3f5, 0x2fc,
          0xdfc, 0xcf5, 0xfff, 0xef6, 0x9fa, 0x8f3, 0xbf9, 0xaf0,
          0x650, 0x759, 0x453, 0x55a, 0x256, 0x35f, 0x55, 0x15c,
          0xe5c, 0xf55, 0xc5f, 0xd56, 0xa5a, 0xb53, 0x859, 0x950,
          0x7c0, 0x6c9, 0x5c3, 0x4ca, 0x3c6, 0x2cf, 0x1c5, 0xcc,
          0xfcc, 0xec5, 0xdcf, 0xcc6, 0xbca, 0xac3, 0x9c9, 0x8c0,
          0x8c0, 0x9c9, 0xac3, 0xbca, 0xcc6, 0xdcf, 0xec5, 0xfcc,
          0xcc, 0x1c5, 0x2cf, 0x3c6, 0x4ca, 0x5c3, 0x6c9, 0x7c0,
          0x950, 0x859, 0xb53, 0xa5a, 0xd56, 0xc5f, 0xf55, 0xe5c,
          0x15c, 0x55, 0x35f, 0x256, 0x55a, 0x453, 0x759, 0x650,
          0xaf0, 0xbf9, 0x8f3, 0x9fa, 0xef6, 0xfff, 0xcf5, 0xdfc,
          0x2fc, 0x3f5, 0xff, 0x1f6, 0x6fa, 0x7f3, 0x4f9, 0x5f0,
          0xb60, 0xa69, 0x963, 0x86a, 0xf66, 0xe6f, 0xd65, 0xc6c,
          0x36c, 0x265, 0x16f, 0x66, 0x76a, 0x663, 0x569, 0x460,
          0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac,
          0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa, 0x1a3, 0x2a9, 0x3a0,
          0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c,
          0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33, 0x339, 0x230,
          0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c,
          0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99, 0x190,
          0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c,
          0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0
        ]);

        // Tri table (256 * 16)
        this.triTable = new Int32Array(256 * 16);
        const fullTriTable = [
          [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
          [3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
          [3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
          [3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
          [9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
          [9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
          [2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
          [8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
          [9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
          [4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
          [3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
          [1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
          [4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
          [4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
          [9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
          [5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
          [2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
          [9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
          [0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
          [2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
          [10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
          [4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
          [5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
          [5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
          [9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
          [0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
          [1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
          [10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
          [8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
          [2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
          [7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
          [9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
          [2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
          [11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
          [9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
          [5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
          [11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
          [11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
          [1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
          [9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
          [5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
          [2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
          [0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
          [5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
          [6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
          [3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
          [6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
          [5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
          [1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
          [10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
          [6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
          [8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
          [7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
          [3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
          [5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
          [0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
          [9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
          [8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
          [5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
          [0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
          [6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
          [10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
          [10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
          [8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
          [1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
          [3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
          [0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
          [10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
          [3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
          [6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
          [9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
          [8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
          [3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
          [6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
          [0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
          [10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
          [10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
          [2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
          [7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
          [7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
          [2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
          [1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
          [11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
          [8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
          [0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
          [7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
          [10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
          [2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
          [6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
          [7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
          [2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
          [1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
          [10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
          [10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
          [0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
          [7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
          [6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
          [8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
          [9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
          [6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
          [4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
          [10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
          [8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
          [0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
          [1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
          [8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
          [10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
          [4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
          [10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
          [5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
          [11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
          [9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
          [6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
          [7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
          [3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
          [7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
          [9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
          [3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
          [6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
          [9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
          [1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
          [4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
          [7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
          [6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
          [3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
          [0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
          [6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
          [0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
          [11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
          [6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
          [5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
          [9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
          [1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
          [1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
          [10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
          [0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
          [5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
          [10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
          [11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
          [9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
          [7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
          [2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
          [8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
          [9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
          [9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
          [1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
          [9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
          [9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
          [5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
          [0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
          [10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
          [2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
          [0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
          [0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
          [9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
          [5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
          [3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
          [5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
          [8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
          [0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
          [9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
          [0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
          [1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
          [3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
          [4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
          [9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
          [11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
          [11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
          [2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
          [9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
          [3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
          [1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
          [4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
          [4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
          [0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
          [3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
          [3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
          [0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
          [9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
          [1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
          [-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
        ];
        for (let i = 0; i < 256; i++) {
          for (let j = 0; j < 16; j++) {
            this.triTable[i * 16 + j] = fullTriTable[i][j];
          }
        }
      }

      createShaderModules() {
        this.clearVoxelModule = this.device.createShaderModule({ code: clearVoxelShader, label: "clearVoxel" });
        this.splatPointsModule = this.device.createShaderModule({ code: splatPointsShader, label: "splatPoints" });
        this.normalizeDensityModule = this.device.createShaderModule({ code: normalizeDensityShader, label: "normalizeDensity" });
        this.marchingCubesModule = this.device.createShaderModule({ code: marchingCubesShader, label: "marchingCubes" });
      }

      createPipelines() {
        this.clearVoxelPipeline = this.device.createComputePipeline({ label: "clearVoxel", layout: "auto", compute: { module: this.clearVoxelModule, entryPoint: "main" } });
        this.splatPointsPipeline = this.device.createComputePipeline({ label: "splatPoints", layout: "auto", compute: { module: this.splatPointsModule, entryPoint: "main" } });
        this.normalizeDensityPipeline = this.device.createComputePipeline({ label: "normalizeDensity", layout: "auto", compute: { module: this.normalizeDensityModule, entryPoint: "main" } });
        this.marchingCubesPipeline = this.device.createComputePipeline({ label: "marchingCubes", layout: "auto", compute: { module: this.marchingCubesModule, entryPoint: "main" } });
      }

      setPointCloud(positions, colors, count, gridRes) {
        if (!this.initialized) return;
        this.destroyBuffers();
        this.numPoints = count;
        this.gridSize = [gridRes, gridRes, gridRes];
        const gridCount = gridRes * gridRes * gridRes;

        // ËÆ°ÁÆóÂåÖÂõ¥Áõí
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        for (let i = 0; i < count; i++) {
          const x = positions[i * 3], y = positions[i * 3 + 1], z = positions[i * 3 + 2];
          minX = Math.min(minX, x); maxX = Math.max(maxX, x);
          minY = Math.min(minY, y); maxY = Math.max(maxY, y);
          minZ = Math.min(minZ, z); maxZ = Math.max(maxZ, z);
        }
        const padding = this.params.splatRadius * 2;
        this.params.gridMin = [minX - padding, minY - padding, minZ - padding];
        this.params.gridMax = [maxX + padding, maxY + padding, maxZ + padding];

        // ÁÇπ‰∫ë‰ΩçÁΩÆÁºìÂÜ≤Âå∫
        const pointData = new Float32Array(count * 4);
        for (let i = 0; i < count; i++) {
          pointData[i * 4] = positions[i * 3];
          pointData[i * 4 + 1] = positions[i * 3 + 1];
          pointData[i * 4 + 2] = positions[i * 3 + 2];
          pointData[i * 4 + 3] = 0;
        }
        this.pointsBuffer = this.device.createBuffer({ label: "points", size: count * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.pointsBuffer, 0, pointData);

        // È¢úËâ≤ÁºìÂÜ≤Âå∫
        const colorData = new Float32Array(count * 4);
        for (let i = 0; i < count; i++) {
          colorData[i * 4] = colors ? colors[i * 3] : 0.5;
          colorData[i * 4 + 1] = colors ? colors[i * 3 + 1] : 0.5;
          colorData[i * 4 + 2] = colors ? colors[i * 3 + 2] : 0.5;
          colorData[i * 4 + 3] = 1.0;
        }
        this.colorsBuffer = this.device.createBuffer({ label: "colors", size: count * 16, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.colorsBuffer, 0, colorData);

        // ‰ΩìÁ¥†ÁºìÂÜ≤Âå∫
        this.voxelBuffer = this.device.createBuffer({ label: "voxel", size: gridCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.voxelColorsRBuffer = this.device.createBuffer({ label: "voxelR", size: gridCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.voxelColorsGBuffer = this.device.createBuffer({ label: "voxelG", size: gridCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.voxelColorsBBuffer = this.device.createBuffer({ label: "voxelB", size: gridCount * 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.normalizedColorsBuffer = this.device.createBuffer({ label: "normalizedColors", size: gridCount * 16, usage: GPUBufferUsage.STORAGE });
        this.densityBuffer = this.device.createBuffer({ label: "density", size: gridCount * 4, usage: GPUBufferUsage.STORAGE });

        // È°∂ÁÇπËæìÂá∫ - ‰ΩøÁî®Âü∫‰∫éË°®Èù¢ÁßØÁöÑÂêàÁêÜ‰º∞ËÆ°
        // ÊúÄÂùèÊÉÖÂÜµÔºöË°®Èù¢‰ΩìÁ¥†Êï∞Á∫¶‰∏∫ 6 * gridRes¬≤ (ÂÖ≠‰∏™Èù¢)ÔºåÊØè‰∏™‰ΩìÁ¥†ÊúÄÂ§ö 5 ‰∏™‰∏âËßíÂΩ¢
        // ÂÆûÈôÖË°®Èù¢ÈÄöÂ∏∏ËøúÂ∞è‰∫éÊ≠§Ôºå‰ΩøÁî® 2x ÂÆâÂÖ®Á≥ªÊï∞
        const surfaceVoxels = 6 * gridRes * gridRes * 2;
        const maxTriangles = Math.min(surfaceVoxels * 5, gridCount);
        const maxVertices = maxTriangles * 3;
        const bytesPerVertex = 48;
        const vertexBufferSize = maxVertices * bytesPerVertex;

        // ÈôêÂà∂ÊúÄÂ§ßÁºìÂÜ≤Âå∫Â§ßÂ∞è‰∏∫ 512MB Êàñ GPU ÈôêÂà∂
        const maxAllowedSize = Math.min(this.maxBufferSize, 512 * 1024 * 1024);
        if (vertexBufferSize > maxAllowedSize) {
          console.warn(`Reducing vertex buffer from ${(vertexBufferSize / 1024 / 1024).toFixed(0)}MB to ${(maxAllowedSize / 1024 / 1024).toFixed(0)}MB`);
        }
        const actualBufferSize = Math.min(vertexBufferSize, maxAllowedSize);

        this.vertexBuffer = this.device.createBuffer({ label: "vertices", size: actualBufferSize, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC });
        this.triangleCountBuffer = this.device.createBuffer({ label: "triCount", size: 4, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST });
        this.readbackBuffer = this.device.createBuffer({ label: "readback", size: actualBufferSize, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });
        this.maxTriangleCount = Math.floor(actualBufferSize / bytesPerVertex / 3);
        this.countReadbackBuffer = this.device.createBuffer({ label: "countReadback", size: 4, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });

        // Uniform ÁºìÂÜ≤Âå∫
        this.gridSizeBuffer = this.device.createBuffer({ label: "gridSize", size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.gridSizeBuffer, 0, new Uint32Array([...this.gridSize, 0]));
        this.numPointsBuffer = this.device.createBuffer({ label: "numPoints", size: 4, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.numPointsBuffer, 0, new Uint32Array([count]));
        this.paramsBuffer = this.device.createBuffer({ label: "splatParams", size: 48, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.mcParamsBuffer = this.device.createBuffer({ label: "mcParams", size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.gridMinBuffer = this.device.createBuffer({ label: "gridMin", size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
        this.gridMaxBuffer = this.device.createBuffer({ label: "gridMax", size: 16, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

        // Êü•ÊâæË°®
        this.edgeTableBuffer = this.device.createBuffer({ label: "edgeTable", size: this.edgeTable.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.edgeTableBuffer, 0, this.edgeTable);
        this.triTableBuffer = this.device.createBuffer({ label: "triTable", size: this.triTable.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });
        this.device.queue.writeBuffer(this.triTableBuffer, 0, this.triTable);

        this.createBindGroups();
      }

      updateSplatParams() {
        const data = new Float32Array([...this.params.gridMin, 0, ...this.params.gridMax, 0, this.params.splatRadius, 0, 0, 0]);
        this.device.queue.writeBuffer(this.paramsBuffer, 0, data);
      }

      updateMCParams() {
        const combined = new ArrayBuffer(16);
        new Float32Array(combined, 0, 1).set([this.params.isoValue]);
        new Uint32Array(combined, 4, 3).set(this.gridSize);
        this.device.queue.writeBuffer(this.mcParamsBuffer, 0, combined);
        this.device.queue.writeBuffer(this.gridMinBuffer, 0, new Float32Array([...this.params.gridMin, 0]));
        this.device.queue.writeBuffer(this.gridMaxBuffer, 0, new Float32Array([...this.params.gridMax, 0]));
      }

      createBindGroups() {
        this.clearVoxelBindGroup = this.device.createBindGroup({
          label: "clearVoxel", layout: this.clearVoxelPipeline.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: this.voxelBuffer } },
            { binding: 1, resource: { buffer: this.voxelColorsRBuffer } },
            { binding: 2, resource: { buffer: this.voxelColorsGBuffer } },
            { binding: 3, resource: { buffer: this.voxelColorsBBuffer } },
            { binding: 4, resource: { buffer: this.gridSizeBuffer } },
          ]
        });
        this.splatPointsBindGroup = this.device.createBindGroup({
          label: "splatPoints", layout: this.splatPointsPipeline.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: this.pointsBuffer } },
            { binding: 1, resource: { buffer: this.colorsBuffer } },
            { binding: 2, resource: { buffer: this.voxelBuffer } },
            { binding: 3, resource: { buffer: this.voxelColorsRBuffer } },
            { binding: 4, resource: { buffer: this.voxelColorsGBuffer } },
            { binding: 5, resource: { buffer: this.voxelColorsBBuffer } },
            { binding: 6, resource: { buffer: this.gridSizeBuffer } },
            { binding: 7, resource: { buffer: this.numPointsBuffer } },
            { binding: 8, resource: { buffer: this.paramsBuffer } },
          ]
        });
        this.normalizeDensityBindGroup = this.device.createBindGroup({
          label: "normalizeDensity", layout: this.normalizeDensityPipeline.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: this.voxelBuffer } },
            { binding: 1, resource: { buffer: this.densityBuffer } },
            { binding: 2, resource: { buffer: this.gridSizeBuffer } },
            { binding: 3, resource: { buffer: this.voxelColorsRBuffer } },
            { binding: 4, resource: { buffer: this.voxelColorsGBuffer } },
            { binding: 5, resource: { buffer: this.voxelColorsBBuffer } },
            { binding: 6, resource: { buffer: this.normalizedColorsBuffer } },
          ]
        });
        this.marchingCubesBindGroup = this.device.createBindGroup({
          label: "marchingCubes", layout: this.marchingCubesPipeline.getBindGroupLayout(0), entries: [
            { binding: 0, resource: { buffer: this.densityBuffer } },
            { binding: 1, resource: { buffer: this.vertexBuffer } },
            { binding: 2, resource: { buffer: this.triangleCountBuffer } },
            { binding: 3, resource: { buffer: this.mcParamsBuffer } },
            { binding: 4, resource: { buffer: this.edgeTableBuffer } },
            { binding: 5, resource: { buffer: this.triTableBuffer } },
            { binding: 6, resource: { buffer: this.gridMinBuffer } },
            { binding: 7, resource: { buffer: this.gridMaxBuffer } },
            { binding: 8, resource: { buffer: this.normalizedColorsBuffer } },
          ]
        });
      }

      async reconstruct() {
        if (!this.initialized || !this.pointsBuffer) return null;
        const startTime = performance.now();
        this.updateSplatParams();
        this.updateMCParams();

        const gridCount = this.gridSize[0] * this.gridSize[1] * this.gridSize[2];
        const pointWorkgroups = Math.ceil(this.numPoints / 64);
        const gridWorkgroups = Math.ceil(gridCount / 64);
        this.device.queue.writeBuffer(this.triangleCountBuffer, 0, new Uint32Array([0]));

        const commandEncoder = this.device.createCommandEncoder();
        // Clear
        const clearPass = commandEncoder.beginComputePass();
        clearPass.setPipeline(this.clearVoxelPipeline);
        clearPass.setBindGroup(0, this.clearVoxelBindGroup);
        clearPass.dispatchWorkgroups(gridWorkgroups);
        clearPass.end();
        // Splat
        const splatPass = commandEncoder.beginComputePass();
        splatPass.setPipeline(this.splatPointsPipeline);
        splatPass.setBindGroup(0, this.splatPointsBindGroup);
        splatPass.dispatchWorkgroups(pointWorkgroups);
        splatPass.end();
        // Normalize
        const normalizePass = commandEncoder.beginComputePass();
        normalizePass.setPipeline(this.normalizeDensityPipeline);
        normalizePass.setBindGroup(0, this.normalizeDensityBindGroup);
        normalizePass.dispatchWorkgroups(gridWorkgroups);
        normalizePass.end();
        // Marching Cubes
        const mcPass = commandEncoder.beginComputePass();
        mcPass.setPipeline(this.marchingCubesPipeline);
        mcPass.setBindGroup(0, this.marchingCubesBindGroup);
        mcPass.dispatchWorkgroups(Math.ceil(this.gridSize[0] / 4), Math.ceil(this.gridSize[1] / 4), Math.ceil(this.gridSize[2] / 4));
        mcPass.end();

        commandEncoder.copyBufferToBuffer(this.triangleCountBuffer, 0, this.countReadbackBuffer, 0, 4);
        this.device.queue.submit([commandEncoder.finish()]);

        await this.countReadbackBuffer.mapAsync(GPUMapMode.READ);
        const countData = new Uint32Array(this.countReadbackBuffer.getMappedRange().slice(0));
        this.countReadbackBuffer.unmap();
        this.triangleCount = Math.min(countData[0], this.maxTriangleCount || countData[0]);

        if (this.triangleCount === 0) {
          this.lastComputeTime = performance.now() - startTime;
          return { positions: new Float32Array(0), normals: new Float32Array(0), colors: new Float32Array(0), triangleCount: 0 };
        }

        // ÈôêÂà∂ÂÆûÈôÖËØªÂèñÁöÑÈ°∂ÁÇπÊï∞
        const actualTriangles = Math.min(this.triangleCount, this.maxTriangleCount || this.triangleCount);
        const vertexCount = actualTriangles * 3;
        const bytesPerVertex = 48;
        const readSize = Math.min(vertexCount * bytesPerVertex, this.readbackBuffer.size);

        const copyEncoder = this.device.createCommandEncoder();
        copyEncoder.copyBufferToBuffer(this.vertexBuffer, 0, this.readbackBuffer, 0, readSize);
        this.device.queue.submit([copyEncoder.finish()]);

        await this.readbackBuffer.mapAsync(GPUMapMode.READ);
        const vertexData = new Float32Array(this.readbackBuffer.getMappedRange(0, readSize).slice(0));
        this.readbackBuffer.unmap();

        const positions = new Float32Array(vertexCount * 3);
        const normals = new Float32Array(vertexCount * 3);
        const colors = new Float32Array(vertexCount * 3);

        for (let i = 0; i < vertexCount; i++) {
          positions[i * 3] = vertexData[i * 12];
          positions[i * 3 + 1] = vertexData[i * 12 + 1];
          positions[i * 3 + 2] = vertexData[i * 12 + 2];
          normals[i * 3] = vertexData[i * 12 + 4];
          normals[i * 3 + 1] = vertexData[i * 12 + 5];
          normals[i * 3 + 2] = vertexData[i * 12 + 6];
          colors[i * 3] = vertexData[i * 12 + 8];
          colors[i * 3 + 1] = vertexData[i * 12 + 9];
          colors[i * 3 + 2] = vertexData[i * 12 + 10];
        }

        this.lastComputeTime = performance.now() - startTime;
        return { positions, normals, colors, triangleCount: this.triangleCount };
      }

      destroyBuffers() {
        const buffers = ['pointsBuffer', 'colorsBuffer', 'voxelBuffer', 'voxelColorsRBuffer', 'voxelColorsGBuffer', 'voxelColorsBBuffer', 'normalizedColorsBuffer', 'densityBuffer', 'vertexBuffer', 'triangleCountBuffer', 'readbackBuffer', 'countReadbackBuffer', 'paramsBuffer', 'mcParamsBuffer', 'gridSizeBuffer', 'numPointsBuffer', 'gridMinBuffer', 'gridMaxBuffer'];
        buffers.forEach(name => { if (this[name]) { this[name].destroy(); this[name] = null; } });
      }

      destroy() {
        this.destroyBuffers();
        if (this.edgeTableBuffer) { this.edgeTableBuffer.destroy(); this.edgeTableBuffer = null; }
        if (this.triTableBuffer) { this.triTableBuffer.destroy(); this.triTableBuffer = null; }
      }
    }

    // ==================== ‰∏ªÁ®ãÂ∫è ====================
    const canvas = document.getElementById("canvas");

    // ÂÖ®Â±ÄÂèòÈáèÔºàÂ∞ÜÂú®ÂºÇÊ≠•ÂàùÂßãÂåñÂêéËµãÂÄºÔºâ
    let renderer = null;
    let controls = null;
    let scene = null;
    let camera = null;

    // ==================== Áä∂ÊÄÅ ====================
    let currentShape = "sphere";
    let pointCount = 500000;
    let pointSize = 1.5;
    let animSpeed = 0.5;
    let colorScheme = 0;
    let points = null;
    let material = null;
    let geometry = null;
    let genTime = 0;

    // ÊÄßËÉΩÁªüËÆ°
    let frameCount = 0;
    let lastFpsTime = performance.now();
    let currentFps = 0;
    let lastUiUpdate = 0;

    // ÁΩëÊ†ºÈáçÂª∫Áä∂ÊÄÅ
    let meshEnabled = false;
    let meshReconstructor = null;
    let gridResolution = 64;
    let meshParams = { isoValue: 0.5, splatRadius: 2.0, meshOpacity: 0.9 };
    let reconstructedMesh = null;
    let triangleCount = 0;
    let computeTime = 0;

    // ==================== ÂàõÂª∫ÂΩ¢ÊÄÅÊåâÈíÆ ====================
    const shapeButtonsContainer = document.getElementById("shapeButtons");
    Object.entries(SHAPES).forEach(([key, shape]) => {
      const btn = document.createElement("button");
      btn.className = "shape-btn" + (key === currentShape ? " active" : "");
      btn.textContent = shape.icon + " " + shape.name;
      btn.dataset.shape = key;
      btn.addEventListener("click", () => {
        currentShape = key;
        document.querySelectorAll(".shape-btn").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        rebuildPointCloud();
        updateTechNote();
      });
      shapeButtonsContainer.appendChild(btn);
    });

    // ==================== CPU ÁîüÊàêÁÇπ‰∫ëÊï∞ÊçÆ ====================
    function generatePointsCPU(shape, count, time = 0) {
      const positions = new Float32Array(count * 3);
      const TAU = Math.PI * 2;

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        const r1 = Math.random();
        const r2 = Math.random();
        const r3 = Math.random();

        let x, y, z;

        switch (shape) {
          case "sphere": {
            const theta = r1 * TAU;
            const phi = Math.acos(2 * r2 - 1);
            const radius = 50 * Math.pow(r3, 0.333);
            x = radius * Math.sin(phi) * Math.cos(theta);
            y = radius * Math.cos(phi);
            z = radius * Math.sin(phi) * Math.sin(theta);
            break;
          }
          case "cube": {
            x = (r1 - 0.5) * 100;
            y = (r2 - 0.5) * 100;
            z = (r3 - 0.5) * 100;
            break;
          }
          case "wave": {
            x = (r1 - 0.5) * 100;
            z = (r2 - 0.5) * 100;
            y = Math.sin(x * 0.1 + time) * 10 + Math.cos(z * 0.1 + time * 0.7) * 10;
            y += (r3 - 0.5) * 5;
            break;
          }
          case "galaxy": {
            const arm = Math.floor(r1 * 4);
            const t = r2;
            let angle = arm * Math.PI * 0.5 + t * Math.PI * 2 + t * t * Math.PI;
            const radius = t * 50 + r3 * 10;
            const height = (Math.random() - 0.5) * 10 * (1 - t);
            x = Math.cos(angle) * radius;
            y = height;
            z = Math.sin(angle) * radius;
            break;
          }
          default:
            x = (r1 - 0.5) * 100;
            y = (r2 - 0.5) * 100;
            z = (r3 - 0.5) * 100;
        }

        positions[i3] = x;
        positions[i3 + 1] = y;
        positions[i3 + 2] = z;
      }

      return positions;
    }

    // ==================== ÂàõÂª∫ÁÇπ‰∫ë ====================
    function rebuildPointCloud() {
      if (!scene) return;  // Á≠âÂæÖÂàùÂßãÂåñÂÆåÊàê

      // Ê∏ÖÁêÜÊóßÁöÑ
      if (points) {
        scene.remove(points);
        geometry.dispose();
        material.dispose();
      }

      const startTime = performance.now();

      geometry = new THREE.BufferGeometry();

      // ÂáÜÂ§áÈ°∂ÁÇπÂ±ûÊÄßÊï∞ÊçÆ
      const basePositions = new Float32Array(pointCount * 3);
      const randoms = new Float32Array(pointCount);

      for (let i = 0; i < pointCount; i++) {
        basePositions[i * 3] = Math.random();
        basePositions[i * 3 + 1] = Math.random();
        basePositions[i * 3 + 2] = Math.random();
        randoms[i] = Math.random();
      }

      // GPU ÁîüÊàêÔºö‰º†ÈÄíÈöèÊú∫ÁßçÂ≠êÔºåÂú®ÁùÄËâ≤Âô®‰∏≠ËÆ°ÁÆó‰ΩçÁΩÆ
      geometry.setAttribute("position", new THREE.BufferAttribute(basePositions, 3));

      geometry.setAttribute("aBasePosition", new THREE.BufferAttribute(basePositions, 3));
      geometry.setAttribute("aRandom", new THREE.BufferAttribute(randoms, 1));

      // Êõ¥Êñ∞ uniform ÂÄº
      uSize.value = pointSize;
      uAnimSpeed.value = animSpeed;
      uShape.value = Object.keys(SHAPES).indexOf(currentShape);
      uColorScheme.value = colorScheme;

      // Ëé∑ÂèñÈ°∂ÁÇπÂ±ûÊÄßËäÇÁÇπ
      const aBasePosition = attribute("aBasePosition", "vec3");
      const aRandom = attribute("aRandom", "float");

      // ËÆ°ÁÆóÊó∂Èó¥ÂÄº
      const time = uTime.mul(uAnimSpeed);

      // TSL ÂΩ¢ÊÄÅÁîüÊàêËäÇÁÇπ - Ê†πÊçÆ shape ÈÄâÊã©‰∏çÂêåÁîüÊàêÂô®
      const shape = uShape.toInt();

      // Ë∞ÉÁî®ÂΩ¢ÊÄÅÁîüÊàêÂáΩÊï∞
      const posSphere = generateSphere(aBasePosition, aRandom, time);
      const posCube = generateCube(aBasePosition, aRandom, time);
      const posWave = generateWave(aBasePosition, aRandom, time);
      const posGalaxy = generateGalaxy(aBasePosition, aRandom, time);

      // Ê†πÊçÆ shape ÈÄâÊã©‰ΩçÁΩÆÔºà‰ΩøÁî®Á∫ßËÅî mix + stepÔºâ
      const shapeF = uShape.toFloat();
      const gpuPos = mix(
        mix(
          mix(posSphere, posCube, step(0.5, shapeF)),
          posWave, step(1.5, shapeF)
        ),
        posGalaxy, step(2.5, shapeF)
      );

      const finalPos = gpuPos;

      // È¢úËâ≤ËäÇÁÇπ
      const colorResult = computeColor(finalPos, uColorScheme.toFloat());

      // ÁÇπÂ§ßÂ∞èËäÇÁÇπ - Ë∑ùÁ¶ªË°∞Âáè
      const mvPosition = modelViewMatrix.mul(vec4(finalPos, 1.0));
      const dist = mvPosition.z.negate();
      const size = uSize.mul(float(300.0).div(dist)).clamp(1.0, 50.0);

      // ÂàõÂª∫ PointsNodeMaterial
      material = new THREE.PointsNodeMaterial({
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: false,  // Êàë‰ª¨Ëá™Â∑±Â§ÑÁêÜË°∞Âáè
      });

      // ËÆæÁΩÆËäÇÁÇπ
      material.positionNode = finalPos;
      material.colorNode = vec4(colorResult, 1.0);
      material.sizeNode = size;

      points = new THREE.Points(geometry, material);
      scene.add(points);

      genTime = performance.now() - startTime;
    }

    // ==================== ÁΩëÊ†ºÈáçÂª∫ÂáΩÊï∞ ====================
    async function initMeshReconstructor() {
      if (!navigator.gpu) {
        console.warn("WebGPU not available for mesh reconstruction");
        document.getElementById("infoMesh").textContent = "‰∏çÂèØÁî®";
        return false;
      }
      meshReconstructor = new MeshReconstructor();
      const success = await meshReconstructor.init();
      if (success) {
        document.getElementById("infoMesh").textContent = "Â∑≤Â∞±Áª™";
      } else {
        document.getElementById("infoMesh").textContent = "ÂàùÂßãÂåñÂ§±Ë¥•";
      }
      return success;
    }

    function generatePointColors() {
      // ‰ªéÂΩìÂâçÁÇπ‰∫ëÁîüÊàêÂØπÂ∫îÁöÑÈ¢úËâ≤Êï∞ÊçÆ
      // ‰ΩøÁî® CPU Ê®°ÂºèÁîüÊàê‰ΩçÁΩÆÂêéËÆ°ÁÆóÈ¢úËâ≤
      const positions = generatePointsCPU(currentShape, pointCount);
      const colors = new Float32Array(pointCount * 3);

      for (let i = 0; i < pointCount; i++) {
        const x = positions[i * 3];
        const y = positions[i * 3 + 1];
        const z = positions[i * 3 + 2];
        const r = Math.sqrt(x * x + y * y + z * z);

        let cr, cg, cb;
        switch (colorScheme) {
          case 0: // ÂéüÂßãÔºöÂü∫‰∫é‰ΩçÁΩÆ
            cr = (x / 100 + 0.5);
            cg = (y / 100 + 0.5);
            cb = (z / 100 + 0.5);
            break;
          case 1: // Ê∑±Â∫¶ÔºöÂü∫‰∫éÂçäÂæÑ
            const t = r / 60;
            cr = 0.1 + t * 0.3;
            cg = 0.2 + t * 0.5;
            cb = 0.8 - t * 0.3;
            break;
          case 2: // ÂæÑÂêëÔºö‰ªé‰∏≠ÂøÉÂà∞Â§ñÁöÑÊ∏êÂèò
            const n = r / 50;
            cr = Math.sin(n * Math.PI * 0.5);
            cg = Math.sin(n * Math.PI);
            cb = Math.cos(n * Math.PI * 0.5);
            break;
          case 3: // ÂΩ©ËôπÔºöÂü∫‰∫éËßíÂ∫¶
            const theta = Math.atan2(z, x);
            const hue = (theta + Math.PI) / (2 * Math.PI);
            const h = hue * 6;
            const c = 1, X = 1 - Math.abs(h % 2 - 1);
            if (h < 1) { cr = c; cg = X; cb = 0; }
            else if (h < 2) { cr = X; cg = c; cb = 0; }
            else if (h < 3) { cr = 0; cg = c; cb = X; }
            else if (h < 4) { cr = 0; cg = X; cb = c; }
            else if (h < 5) { cr = X; cg = 0; cb = c; }
            else { cr = c; cg = 0; cb = X; }
            break;
          default:
            cr = cg = cb = 0.5;
        }

        colors[i * 3] = Math.max(0, Math.min(1, cr));
        colors[i * 3 + 1] = Math.max(0, Math.min(1, cg));
        colors[i * 3 + 2] = Math.max(0, Math.min(1, cb));
      }

      return { positions, colors };
    }

    async function rebuildMesh() {
      if (!meshReconstructor || !meshReconstructor.initialized) {
        console.warn("MeshReconstructor not initialized");
        return;
      }

      document.getElementById("infoMesh").textContent = "ÈáçÂª∫‰∏≠...";

      try {
        // ÁîüÊàêÁÇπ‰∫ë‰ΩçÁΩÆÂíåÈ¢úËâ≤
        const { positions, colors } = generatePointColors();

        // ËÆæÁΩÆÂèÇÊï∞
        meshReconstructor.params.isoValue = meshParams.isoValue;
        meshReconstructor.params.splatRadius = meshParams.splatRadius;

        // ÂáÜÂ§áÁÇπ‰∫ëÊï∞ÊçÆ
        meshReconstructor.setPointCloud(positions, colors, pointCount, gridResolution);

        // ÊâßË°åÈáçÂª∫
        const result = await meshReconstructor.reconstruct();

        if (!result || result.triangleCount === 0) {
          document.getElementById("infoMesh").textContent = "Êó†‰∏âËßíÂΩ¢";
          document.getElementById("infoTriangles").textContent = "0";
          clearMesh();
          return;
        }

        triangleCount = result.triangleCount;
        computeTime = meshReconstructor.lastComputeTime;

        document.getElementById("infoMesh").textContent = "Â∑≤ÂÆåÊàê";
        document.getElementById("infoTriangles").textContent = triangleCount.toLocaleString();
        document.getElementById("infoComputeTime").textContent = computeTime.toFixed(1) + " ms";

        // ÁßªÈô§ÊóßÁΩëÊ†º
        clearMesh();

        // ÂàõÂª∫ Three.js ÁΩëÊ†º
        const meshGeometry = new THREE.BufferGeometry();
        meshGeometry.setAttribute("position", new THREE.BufferAttribute(result.positions, 3));
        meshGeometry.setAttribute("normal", new THREE.BufferAttribute(result.normals, 3));
        meshGeometry.setAttribute("color", new THREE.BufferAttribute(result.colors, 3));

        const meshMaterial = new THREE.MeshPhysicalMaterial({
          vertexColors: true,
          transparent: true,
          opacity: meshParams.meshOpacity,
          metalness: 0.1,
          roughness: 0.4,
          side: THREE.DoubleSide,
          flatShading: false,
        });

        reconstructedMesh = new THREE.Mesh(meshGeometry, meshMaterial);
        scene.add(reconstructedMesh);

        console.log(`Mesh reconstructed: ${triangleCount} triangles in ${computeTime.toFixed(1)}ms`);

      } catch (e) {
        console.error("Mesh reconstruction failed:", e);
        document.getElementById("infoMesh").textContent = "Â§±Ë¥•: " + e.message;
      }
    }

    function clearMesh() {
      if (reconstructedMesh) {
        scene.remove(reconstructedMesh);
        reconstructedMesh.geometry.dispose();
        reconstructedMesh.material.dispose();
        reconstructedMesh = null;
      }
    }

    // ==================== UI ÁªëÂÆö ====================
    const countSlider = document.getElementById("countSlider");
    const countValue = document.getElementById("countValue");
    const sizeSlider = document.getElementById("sizeSlider");
    const sizeValue = document.getElementById("sizeValue");
    const speedSlider = document.getElementById("speedSlider");
    const speedValue = document.getElementById("speedValue");
    const colorSelect = document.getElementById("colorScheme");

    countSlider.addEventListener("input", () => {
      pointCount = Number(countSlider.value);
      countValue.textContent = (pointCount / 10000).toFixed(0) + "‰∏á";
    });
    countSlider.addEventListener("change", rebuildPointCloud);

    sizeSlider.addEventListener("input", () => {
      pointSize = Number(sizeSlider.value);
      sizeValue.textContent = pointSize.toFixed(1);
      uSize.value = pointSize;  // TSL uniform Áõ¥Êé•Êõ¥Êñ∞
    });

    speedSlider.addEventListener("input", () => {
      animSpeed = Number(speedSlider.value);
      speedValue.textContent = animSpeed.toFixed(1);
      uAnimSpeed.value = animSpeed;  // TSL uniform Áõ¥Êé•Êõ¥Êñ∞
    });

    colorSelect.addEventListener("change", () => {
      colorScheme = colorSelect.selectedIndex;
      uColorScheme.value = colorScheme;  // TSL uniform Áõ¥Êé•Êõ¥Êñ∞
    });

    // ==================== ÁΩëÊ†ºÈáçÂª∫ UI ÁªëÂÆö ====================
    document.getElementById("meshToggle").addEventListener("click", function () {
      meshEnabled = !meshEnabled;
      this.classList.toggle("active", meshEnabled);
      this.textContent = `ÁΩëÊ†ºÔºö${meshEnabled ? "ÂºÄ" : "ÂÖ≥"}`;

      if (meshEnabled) {
        if (meshReconstructor && meshReconstructor.initialized) {
          rebuildMesh();
        } else {
          // È¶ñÊ¨°ÂêØÁî®Êó∂ÂàùÂßãÂåñ
          initMeshReconstructor().then(success => {
            if (success) rebuildMesh();
          });
        }
        // ÈöêËóèÁÇπ‰∫ë
        if (points) points.visible = false;
      } else {
        clearMesh();
        // ÊòæÁ§∫ÁÇπ‰∫ë
        if (points) points.visible = true;
      }
    });

    document.getElementById("rebuildMesh").addEventListener("click", () => {
      if (meshEnabled && meshReconstructor && meshReconstructor.initialized) {
        rebuildMesh();
      }
    });

    // ÁΩëÊ†ºÂèÇÊï∞ÊªëÂùó
    const gridResSlider = document.getElementById("gridResSlider");
    const gridResValue = document.getElementById("gridResValue");
    const isoValueSlider = document.getElementById("isoValueSlider");
    const isoValueValue = document.getElementById("isoValueValue");
    const splatRadiusSlider = document.getElementById("splatRadiusSlider");
    const splatRadiusValue = document.getElementById("splatRadiusValue");
    const meshOpacitySlider = document.getElementById("meshOpacitySlider");
    const meshOpacityValue = document.getElementById("meshOpacityValue");

    gridResSlider.addEventListener("input", () => {
      gridResolution = Number(gridResSlider.value);
      gridResValue.textContent = gridResolution;
    });
    gridResSlider.addEventListener("change", () => {
      if (meshEnabled && meshReconstructor && meshReconstructor.initialized) {
        rebuildMesh();
      }
    });

    isoValueSlider.addEventListener("input", () => {
      meshParams.isoValue = Number(isoValueSlider.value);
      isoValueValue.textContent = meshParams.isoValue.toFixed(2);
    });
    isoValueSlider.addEventListener("change", () => {
      if (meshEnabled && meshReconstructor && meshReconstructor.initialized) {
        rebuildMesh();
      }
    });

    splatRadiusSlider.addEventListener("input", () => {
      meshParams.splatRadius = Number(splatRadiusSlider.value);
      splatRadiusValue.textContent = meshParams.splatRadius.toFixed(1);
    });
    splatRadiusSlider.addEventListener("change", () => {
      if (meshEnabled && meshReconstructor && meshReconstructor.initialized) {
        rebuildMesh();
      }
    });

    meshOpacitySlider.addEventListener("input", () => {
      meshParams.meshOpacity = Number(meshOpacitySlider.value);
      meshOpacityValue.textContent = meshParams.meshOpacity.toFixed(1);
      if (reconstructedMesh) {
        reconstructedMesh.material.opacity = meshParams.meshOpacity;
      }
    });

    // ==================== ‰∏ªÂæ™ÁéØ ====================
    let time = 0;

    function render() {
      requestAnimationFrame(render);
      if (!renderer) return;  // Á≠âÂæÖÂàùÂßãÂåñÂÆåÊàê

      const now = performance.now();

      // FPS
      frameCount++;
      if (now - lastFpsTime >= 1000) {
        currentFps = frameCount;
        frameCount = 0;
        lastFpsTime = now;
      }

      // Êõ¥Êñ∞Âä®ÁîªÔºàÂõ∫ÂÆöÂºÄÂêØÔºâ
      time += 0.016;
      uTime.value = time;  // TSL uniform Áõ¥Êé•Êõ¥Êñ∞

      controls.update();
      renderer.renderAsync(scene, camera);  // WebGPU ‰ΩøÁî® renderAsync

      // Êõ¥Êñ∞ UI (ÊØè100ms)
      if (now - lastUiUpdate >= 100) {
        lastUiUpdate = now;
        const infoShape = document.getElementById("infoShape");
        const infoCount = document.getElementById("infoCount");
        const infoGenTime = document.getElementById("infoGenTime");
        const infoRenderMode = document.getElementById("infoRenderMode");
        const infoFps = document.getElementById("infoFps");
        const infoDrawCalls = document.getElementById("infoDrawCalls");

        if (infoShape) infoShape.textContent = SHAPES[currentShape].name;
        if (infoCount) infoCount.textContent = pointCount.toLocaleString();
        if (infoGenTime) infoGenTime.textContent = genTime.toFixed(1);
        if (infoRenderMode) infoRenderMode.textContent = "GPU ÁùÄËâ≤Âô® (WebGPU)";
        if (infoFps) infoFps.textContent = currentFps;
        if (infoDrawCalls && renderer.info) infoDrawCalls.textContent = renderer.info.render?.calls ?? 0;
      }
    }

    // ==================== Á™óÂè£Â§ßÂ∞è ====================
    window.addEventListener("resize", () => {
      if (!camera || !renderer) return;
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // ==================== ÂºÇÊ≠•ÂàùÂßãÂåñ ====================
    async function init() {
      // Ê£ÄÊµã WebGPU ÊîØÊåÅ
      if (!navigator.gpu) {
        console.error("WebGPU is not supported in this browser");
        return;
      }

      // ÂàõÂª∫ WebGPU Ê∏≤ÊüìÂô®
      renderer = new THREE.WebGPURenderer({
        canvas,
        antialias: true,
        powerPreference: "high-performance"
      });

      // Á≠âÂæÖ WebGPU ÂàùÂßãÂåñÂÆåÊàê
      await renderer.init();

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x0a0d12, 1);

      // Ëé∑Âèñ GPU ‰ø°ÊÅØ (WebGPU ÊñπÂºè)
      const adapter = await navigator.gpu.requestAdapter({ powerPreference: "high-performance" });
      const adapterInfo = adapter.info; // WebGPU API Êõ¥Êñ∞: requestAdapterInfo() -> info Â±ûÊÄß

      const gpuInfo = {
        renderer: adapterInfo.device || adapterInfo.description || "WebGPU Device",
        vendor: adapterInfo.vendor || "Unknown",
        architecture: adapterInfo.architecture || "Unknown",
        backend: renderer.backend?.constructor?.name || "WebGPU",
        maxTexture: adapter.limits.maxTextureDimension2D,
        maxBufferSize: (adapter.limits.maxBufferSize / 1024 / 1024).toFixed(0) + " MB",
      };

      // Âú∫ÊôØ
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
      camera.position.set(0, 50, 150);

      // ÁÅØÂÖâ (Áî®‰∫éÁΩëÊ†ºÊ∏≤Êüì)
      const ambientLight = new THREE.AmbientLight(0x404050, 0.5);
      scene.add(ambientLight);

      const directionalLight1 = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight1.position.set(100, 100, 100);
      scene.add(directionalLight1);

      const directionalLight2 = new THREE.DirectionalLight(0x6080ff, 0.5);
      directionalLight2.position.set(-100, -50, -100);
      scene.add(directionalLight2);

      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.08;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 1.0;

      // ÂàùÂßãÂåñ UI
      countValue.textContent = (pointCount / 10000).toFixed(0) + "‰∏á";
      sizeValue.textContent = pointSize.toFixed(1);
      speedValue.textContent = animSpeed.toFixed(1);
      gridResValue.textContent = gridResolution;
      isoValueValue.textContent = meshParams.isoValue.toFixed(2);
      splatRadiusValue.textContent = meshParams.splatRadius.toFixed(1);
      meshOpacityValue.textContent = meshParams.meshOpacity.toFixed(1);

      // ÂàùÂßãÂåñÁΩëÊ†ºÈáçÂª∫Âô® (ÂêéÂè∞)
      initMeshReconstructor();

      // ÂàõÂª∫ÁÇπ‰∫ë
      rebuildPointCloud();

      // ÂºÄÂßãÊ∏≤ÊüìÂæ™ÁéØ
      render();

      console.log("Three.js WebGPU initialized successfully");
    }

    // ÂêØÂä®
    init().catch(console.error);
  </script>
</body>

</html>